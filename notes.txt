
0) Docker prune
1) Road map
2) EStruc. fitxers/directories i URLs, variavles,
3) Github inici
4) github crear versio tag!!

###################################

0) Per errors estranys, si hi ha dockers antic, es poden esborrar tots amb un prune:

docker system prune -a --volumes


###################################

1) Roadmap:

Roadmap (Parts 1 i 2)
Fase A — Bootstrap (Dia 0–1)

    Repo mono: avook.pwa amb apps/api (FastAPI) i apps/web (SvelteKit), infra/ (docker, nginx), i packages/ (si cal SDK compartit).

    Config: .env.example, .env (local), variables per DB, Redis, S3, OAuth (Google/Apple), secrets HMAC/JWT.

    Docker Compose: api, web, db (Postgres), cache (Redis), minio (opcional), nginx reverse proxy.

Fase B — Dades i models (Dia 1–2)

    Esquema mínim (PostgreSQL):

        qr_code(id uuid pk, token text unique, status enum('new','active','blocked'), product_id int, batch_id int, created_at, registered_at, max_reactivations int default 999, cooldown_until timestamptz null)

        account(id uuid pk, email text unique null, provider enum('google','apple','otp','guest'), created_at)

        device(id uuid pk, account_id uuid null, ua_hash text, created_at)

        qr_binding(qr_id uuid fk, device_id uuid fk, account_id uuid null, active bool, created_at, revoked_at null)

        play_session(id uuid pk, qr_id, device_id, started_at, ended_at null, ip_hash text)

        listening_progress(qr_id, account_id null, device_id, track_id text, position_ms int, updated_at, primary key(qr_id, device_id, track_id))

        Indexos útils: idx_qr_token, idx_progress_updated_at, idx_binding_qr_active.

Fase C — Access Manager (Dia 2–4)

    Endpoints:

        POST /api/access/validate → {token, device_id} → status: "new"|"registered"|"invalid", can_reregister, preview_available, cooldown_until.

        POST /api/access/register → primer vincle (qr↔device[↔account]) si status=="new".

        POST /api/access/reregister → mou el vincle a un nou device_id; aplica cooldown si abús.

        GET /api/preview/manifest.m3u8?token=… → playlist efímera per sampler.

    Policies:

        Sessió concurrent única per qr_id: al play-auth expulsa sessions antigues.

        Quota dispositius per qr (p. ex. 3). Si superes la quota en <24 h → cooldown 48 h.

Fase D — Player (Dia 4–6)

    Endpoints:

        POST /api/play-auth → {token, device_id} → {signed_media_url|hls_url, start_position_ms, track_manifest}.

        POST /api/progress → upsert de progrés cada 15–30 s i en pause/end.

    Frontend PWA:

        Rutes: /access?token=…, /player, /purchase (link out), /error.

        svelte-i18n (CA/ES/EN) i DejaVu Sans.

        Controls i A11y (teclat, focus, rols ARIA).

Fase E — Autenticació (Dia 6–8)

    Google/Apple OAuth + OTP magic link.

    Guest opcional: esdevé “comptatitzat” quan verifica OTP o vincula Google/Apple.

    Cookies httpOnly + short JWT (15–30 min) + refresh token (1–7 dies).

Fase F — Streaming (Dia 8–10)

    MVP: HTTP Range amb signed URLs (expiren 60–180 s, device-bound).

    Plus: HLS (segments 6–8s) + playlists efímeres per sampler i play.

Fase G — Qualitat i lliurable (Dia 10–12)

    Tests: PyTest (API) + Playwright (E2E PWA: access→player→resume).

    CI: GitHub Actions (lint, tests, build imatges).

    Hardening: rate limits (Redis), rotació de claus, CORS, CSP bàsica.

    Docs: README, API docs (OpenAPI), decisions d’arquitectura.



###################################
2) 2) EStruc. fitxers/directories i URLs, variavles,

Estructura de carpetes (concreta)

avook.pwa/
  apps/
    api/
      app/
        api/
          access.py
          play.py
          preview.py
          auth.py
        core/
          config.py
          security.py   # HMAC/JWT, sign media
          rate_limit.py
        models/
          base.py
          qr.py
          account.py
          device.py
          binding.py
          progress.py
          session.py
        services/
          storage/
            base.py
            local.py
            s3.py
          media_signer.py
          sampler.py
          oauth.py
          otp.py
      tests/
        api/
    web/
      src/
        routes/
          access/+page.svelte
          player/+page.svelte
          error/+page.svelte
        lib/i18n/
          ca.json es.json en.json
        lib/api.ts
        app.d.ts
  infra/
    docker-compose.yml
    nginx/
      default.conf
  .github/workflows/ci.yml
  .env.example
  Makefile
  README.md

Scripts i ordres útils

Makefile (exemple mínim)

dev:
\tdocker compose -f infra/docker-compose.yml up --build

test:
\tdocker compose -f infra/docker-compose.yml exec -T api pytest -q

format:
\tdocker compose -f infra/docker-compose.yml exec -T api ruff check --fix .

seed:
\tdocker compose -f infra/docker-compose.yml exec -T api python -m app.scripts.seed

Variables .env.example (claus principals)

POSTGRES_USER=avook
POSTGRES_PASSWORD=avook
POSTGRES_DB=avook
REDIS_URL=redis://cache:6379/0
JWT_SECRET=change-me
HMAC_MEDIA_SECRET=change-me-too
OAUTH_GOOGLE_CLIENT_ID=...
OAUTH_GOOGLE_CLIENT_SECRET=...
OAUTH_APPLE_TEAM_ID=...
OAUTH_APPLE_KEY_ID=...
OAUTH_APPLE_PRIVATE_KEY=... # PEM
S3_ENDPOINT=
S3_ACCESS_KEY=
S3_SECRET_KEY=
S3_BUCKET=




###################################
3) GITHUB:

Quick setup — if you’ve done this kind of thing before
git@github.com:jaumet/avook-pwa.git
Get started by creating a new file or uploading an existing file. We recommend every repository include a README, LICENSE, and .gitignore.

…or create a new repository on the command line
echo "# avook-pwa" >> README.md
git init
git add README.md
git commit -m "first commit"
git branch -M main
git remote add origin git@github.com:jaumet/avook-pwa.git
git push -u origin main
…or push an existing repository from the command line
git remote add origin git@github.com:jaumet/avook-pwa.git
git branch -M main
git push -u origin main



#####################################3


Això ho fas amb tags de Git, que serveixen per marcar un estat concret del teu repo (com una “foto fixa”).

1. Crear un tag ara mateix

# crea un tag amb nom v1.0 (posa-hi el que vulguis)
git tag v1.0

# o si vols afegir un missatge (més recomanable):
git tag -a v1.0 -m "Primera versió estable"

2. Pujar el tag a GitHub (o al teu remot)

git push origin v1.0

    Si vols pujar tots els tags de cop:

git push origin --tags

3. Veure quins tags tens

git tag

4. Tornar a un tag en el futur

Aquí tens dues opcions:

    Només mirar el codi d’aquell moment (detached HEAD):

git checkout v1.0

Això et deixa el repo exactament com estava en aquell tag, però no és una branca editable.

    Crear una branca nova a partir d’aquell tag (per treballar-hi):

git checkout -b fix-bug-v1.0 v1.0

